Functor Laws

1) Identity
   fmap id = id

2) Composition
   fmap (g . h) = (fmap g) . (fmap h)



Applicative Laws

1) Identity
   pure id <*> v = v

2) Homomorphism
   pure f <*> pure x = pure (f x)

3) Interchange
   u <*> pure y = pure ($ y) <*> u

4) Composition
   u <*> (v <*> w) = pure (.) <*> u <*> v <*> w

Applicative + Functor
   fmap g x = pure g <*> x



Monoidal Laws

1) Left Identity
   unit ** v ~= v

2) Right Identity
   u ** unit ~= u

3) Associativity:
   u ** (v ** w) ~= (u ** v) ** w

Note: where ~= refers to isomorphism, not equality hence:
      (x, ()) ~= x ~= ((), x)
      ((x, y), z) ~= (x, (y, z))

Naturality
  fmap (g *** h) (u ** v) = fmap g u ** fmap h v



Monad Laws

1) Left Identity
   return x >>= \x -> f x === f x

2) Right Identity
   m >>= return === m

3) Associativity
   (m >>= f) >>= g === m >>= (\x -> f x >>= g)



Left to Right Kleisli Composition (>=>) Laws

1) Left Identity
   return x >=> g = g

2) Right Identity
   m >=> return === g

3) Associativity
   (m >=> f) >=> g === m >=> (f >=> g)



MonadTransformer Laws

1) Identity Law -- ("lifts" return from m to (t m))
   lift . return = return

2) Associativity Law -- ("lifts" (>>=) from m to (t m))
   lift (m >>= f) = lift m >>= (lift . f)



Semigroup Laws

1) Associativity Law
   (x <> y) <> z = x <> (y <> z)



Alternative and MonadPlus Laws

1) Left Identity
   empty <|> x     === x

2) Right Identity
   x <|> empty     === x

3) Associativity Law
   (x <|> y) <|> z === x <|> (y <|> z)

where empty ~= mzero
      (<|>) ~= mplus

1) Choice
   mzero >>= f === mzero

2) Failure
   v >> mzero  === mzero



Arrow Laws

1) arr id === id

2) arr (h . g) === arr g >> arr h

3) first $ arr g === arr (g *** id)

4) first (g >>> h) === first g >>> first h

5) first g >>> arr (id *** h) === arr (id *** h) >>> first g

6) first g >>> arr fst === arr fst >>> g

7) first (first g) >>> arr assoc === arr assoc >>> first g
     where assoc ((x, y), z) = (x, (y, z))

